# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/04_data.core.ipynb (unless otherwise specified).

__all__ = ['Annotation', 'from_mask', 'Mask', 'from_pilmask']

# Cell
from fastai2.vision.all import *

# Cell
# Might be better to custom dispatch annotation, because of recursive tuple problem
# TODO: Dispatch transforms... Can this class inherit from tuple?
# Does it needed to be converted to TensorAnnotation?
# Why is area being converted to BBox??
class Annotation(Tuple):
    keys = 'labels,boxes,area,masks,iscrowd'.split(',') # TODO: Auto insert key in create and d
    @classmethod
    def create(cls, labels=None, boxes=None, masks=None, iscrowd=0):
        area = None if boxes is None else ((boxes[:,3]-boxes[:,1])*(boxes[:,2]-boxes[:,0])).data.clone()
        return cls(labels,boxes,area,masks,iscrowd)
    @property
    def d(self): return {k:v for k,v in zip(self.keys,self)}
    def __getitem__(self, name): return self.d.__getitem__(name)
    def __setitem__(self, n, v): return self.d.__setitem__(n, v)
    def __contains__(self, k): return k in self.d
    def __repr__(self): return self.d.__repr__()
    def show(self, ctx, **kwargs):
        for o in self: ctx = getattr(o,'show',noop)(ctx, **kwargs)
        return ctx

# Cell
@patch_to(TensorBBox, cls_method=True)
def from_mask(cls:TensorBBox, mask):
    boxes = []
    for m in mask.masks:
        xs,ys = m.nonzero().T
        boxes.append([min(ys),min(xs),max(ys),max(xs)])
    return cls(boxes)

# Cell
class Mask:
    def __init__(self, masks, mask_all=None):
        self.masks = TensorMask(masks)
        self.mask_all = mask_all # TODO: caculate when it's None
    def show(self, ctx, **kwargs): return self.mask_all.show(ctx, **kwargs)

# Cell
@patch_to(Mask, cls_method=True)
def from_pilmask(cls, mask:PILMask):
    mask_arr = np.array(mask)
    obj_ids = np.unique(mask_arr)[1:] # TODO: Hardcoded removal
    return cls(mask_arr==obj_ids[:,None,None], mask)