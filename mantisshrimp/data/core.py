# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/04_data.core.ipynb (unless otherwise specified).

__all__ = ['Annotation', 'area', 'from_mask', 'Mask', 'from_pilmask', 'create']

# Cell
from fastai2.vision.all import *

# Cell
# Might be better to custom dispatch annotation, because of recursive tuple problem
# TODO: Dispatch transforms... Can this class inherit from tuple?
# Does it needed to be converted to TensorAnnotation?
# Why is area being converted to BBox??
class Annotation:
    keys = 'labels,boxes,area,masks,iscrowd'.split(',') # TODO: Auto insert key in create and d
#     @classmethod
    def __init__(self, labels=None, boxes=None, masks=None, iscrowd=0, area=None):
        area = boxes.area if (boxes is not None and area is None) else area
        self.d = dict(labels=labels,boxes=boxes,area=area,masks=masks,iscrowd=iscrowd)
#     @property
#     def d(self): return {k:v for k,v in zip(self.keys,self)}
    def __getitem__(self, name): return self.d.__getitem__(name)
    def __setitem__(self, n, v): return self.d.__setitem__(n, v)
    def __contains__(self, k): return k in self.d
    def __repr__(self): return self.d.__repr__()
    def to_tensor(self): return type(self)(**{k:ToTensor()(v) for k,v in self.d.items()})
    def show(self, ctx, **kwargs):
        for o in self.d.values(): ctx = getattr(o,'show',noop)(ctx, **kwargs)
        return ctx

# Cell
@patch_property
def area(self:TensorBBox):
    assert len(self.shape) == 2
    b = self
    return ((b[:,3]-b[:,1])*(b[:,2]-b[:,0])).data

# Cell
@patch_to(TensorBBox, cls_method=True)
def from_mask(cls:TensorBBox, mask):
    boxes = []
    for m in mask.masks:
        xs,ys = m.nonzero().T
        boxes.append([min(ys),min(xs),max(ys),max(xs)])
    return cls(boxes)

# Cell
class Mask:
    def __init__(self, masks, mask_all=None):
        self.masks = TensorMask(masks)
        self.mask_all = mask_all # TODO: caculate when it's None
    def show(self, ctx, **kwargs): return self.mask_all.show(ctx, **kwargs)

# Cell
@patch_to(Mask, cls_method=True)
def from_pilmask(cls, mask:PILMask):
    mask_arr = np.array(mask)
    obj_ids = np.unique(mask_arr)[1:] # TODO: Hardcoded removal
    return cls(mask_arr==obj_ids[:,None,None], mask)

# Cell
# TODO: Merge from_pilmask and create
@patch_to(Mask, cls_method=True)
def create(cls, fn): return cls.from_pilmask(PILMask.create(fn))